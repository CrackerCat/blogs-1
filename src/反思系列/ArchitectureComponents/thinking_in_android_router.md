反思 | 正遭滥用的事件总线，和组件化开发流程中通信机制的设计与实现

## 背景

诸如`EventBus\RxBus\LiveDataBus`的事件总线库在业内正遭滥用。

诚然，事件总线看起来 **小而美** ，但随着业务复杂度上升，事件的发送和订阅到处分布，这个优势反而成为了负担，因此，笔者不建议在任何量级的项目中使用事件总线库。更多原因读者可参考 [这篇文章](https://www.jianshu.com/p/61631134498e) 。

更合理的方案是什么呢？在量级较小的项目中，开发者应该通过 **依赖注入** 将`Callback`进行不同层级的依次传递，以保证 **层级间的依赖关系足够清晰**。

而对于体量逐渐增大的项目而言，项目的模块化、组件化、插件化改造被提上日程，各团队负责不同的业务线，将业务分割成组件，并基于组件本身进行开发，于是我们有了新的诉求，即 **组件与组件保证是隔离的**，同层级的组件间不应该持有其它组件中类的引用。

需要注意的是，即使项目组件化，组件间也仍有通信的场景，但这并非使用事件总线的借口——对大体量的项目而言，`EventBus\RxBus\LiveDataBus`这种事件总线库太局限了，其能力已完全满足不了项目架构的需求，因此，一个适用于组件化开发的 **通信组件** 的需求迫在眉睫。

本文将对组件化开发流程中 **通信组件** 的设计理念与实现方式进行完整的叙述。这里的 **通信组件** 并非特指某个已有的工具库（比如`ARouter`、`WMRouter`等），事实上，它们都是组件化开发流程的实践之一。

本文结构如下：

## 一、组件间通信的基本实现

### 1、Android原生通信机制

对于组件间通信，最经典的场景当属页面跳转，对于`Android`而言，`Activity`之间相互隔离，原生`API`对页面跳转提供了两种实现方式：

第一种方式是常用的 **显式意图**，通过 `startActivity` 或 `startActivityForResult`，这种方案简单且实用，但在组件化开发流程中，组件间未持有其它组件中`Activity.class`的引用，因此无法支持组件间的跳转。

第二种方式则是相对冷僻的 **隐式意图**，这种方式支持组件间以及跨进程通信，比如，开发者可以通过隐式意图唤起系统的呼叫页面：

```java
// 唤起拨号页面
private void call() {
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_CALL);
    intent.setData(Uri.parse("tel:" + 119));
    startActivity(intent);
}
```

由于代码中不存在类依赖的关系，隐式意图更适合组件间通信，但其缺陷也很明显：

* 1.隐式意图需将`Activity`对应的配置规则和参数以`action`等标签的形式，集中声明在`Manifest`中，不利于参数的管理，且扩展性不佳，进而导致团队协作困难；
* 2.开发者对路由控制能力不强，由于整个路由跳转行为都由系统控制，因此，当路由出现异常时，无法进行自定义补救，比如跳转一个错误页面（类似H5的404）。

现在看来，原生`API`对组件间页面跳转能力的提供，确实还略有不足，但这依然不是真正的问题所在。

能真正引爆这些定时炸弹的，只有 **业务需求** 本身。

### 2、导火索

即使`Google`推出了`Navigation`架构组件，很多开发者依然对这种单`Activity`多`Fragment`的开发模式不买账。

**平白无故增加项目复杂度毫无意义**。

无论如何，一个简单的计算器`app`也无必要引入复杂的工程架构，以及组件/插件化的开发流程。

与其热火朝天讨论某个新框架流行与否，读者更想看到它到底是解决了什么问题。

那就是业务的 **爆炸性增长**。

随着微信、支付宝等一众大型和中型应用规模逐渐扩大，即使是原生的跳转机制也无法满足组件化开发的需求，比如，首页的若干个`Tab`对应的不同`Fragment`身处不同组件，这时`Fragment`之间的通信该如何保障？

同时，随着业务粒度的愈发细分，甚至单个`Fragment`中的`View`都来自五湖四海（比如商品详情页面， **视频预览** 和 **商品评论** 的控件分别由不同业务组件提供）; 更深入思索一下，若商品介绍一栏是由`WebView`提供的——涉及到`H5`和原生的交互，我们又该如何定义`H5`与原生间通信的接口？

由此可见，`Activity`自身的通信机制确实已经不够用了。

### 3、组件间通信的基本实现

对于多元化的通信需求而言，首先最重要的是将通信协议进行统一，无论是`Activity`间跳转，还是`Fragment`、`View`之间的通信，亦或是`H5`与原生的交互，我们都通过类似`http`的`url`的形式定义：

```java
// 跳转 用户模块 - 登录页面
String loginUrl = "route://com.example.route/user/activity/login"
// 跳转 用户模块 - 注册页面
String registUrl = "route://com.example.route/user/activity/register"

// 跳转 商品模块 - 详情页面， id为商品的id
String detailUrl = "route://com.example.route/buy/activity/detail?id=xxxxx"    
```

定义好了之后，对于组件间页面跳转，可以如下操作：

```java
Router.route(detailUrl);  // 在用户模块，发起商品模块中页面的跳转
```

应用接收到这样自定义、且支持携带参数的`url`，通信库内部解析后统一分发，进行对应页面的跳转，这样我们就实现了最基础的通信功能。

### 4、降级策略与拦截器机制

接下来我们针对 **隐式意图** 对 **错误处理能力不足** 这点进行深入性讨论。  

在组件化开发流程中，开发者通常在当前的组件的`Demo`上进行开发，虽然模块自身是可运行的，但是当涉及到其它组件的通信，问题随之而来。

和完整的工程相比，`Demo`上未持有其它组件中`Activity`的声明，直接通过 **隐式意图** 发起通信会导致系统抛出异常。

那么，我们希望当通信发生错误时，可以针对不同的环境提供不同的降级策略，以保证开发者和用户的体验，比如：

* 在`Demo`工程的开发流程中，当尝试跳转其它组件时，获得一个「该`url`不在当前组件工程中」的提示；
* 在集成了所有组件的主工程中，在遇到不合法的`url`时，则为用户跳转一个通用的`404`页面。

如有可能，通信库在路由的过程中，能提供限速、屏蔽等 **灵活** 且 **简单** 控制的可能性，那么就更好了。

因此，以`ARouter`为首的绝大多数组件通信库都提供了这种能力，实现方式也使用了非常经典的 **拦截器** 机制，通过 **递归** 将通信事件向下分发，在需要处理的层级中进行拦截处理。

### 5、泼冷水时间？

本小节笔者将以`ARouter`为例，阐述页面间路由库的一些局限性，以及导致这些局限性的原因。

毫无疑问，`ARouter`提供了足够强大的页面间路由跳转能力，它也确实揽括了业内绝大多数开发者的青睐，在开源之初，作者对其的定义就是`Android`平台上的 **页面路由框架** 。

这也变相导致自身对`UI`层级的跳转能力很强，但对数据通信的支持很薄弱。

什么是对数据通信的支持呢？读者知道，除了可见的`UI`交互，数据的交互也非常频繁，比如通过组件间通信，向用户组件获取当前用户信息、向订单组件获取某个订单数据等等。

`ARouter`并不支持这些吗？实际上并非如此，`ARouter`自身提供了`IProvider`接口实现组件间服务的管理，并提供服务的自动注册和依赖注入。

但遗憾的是，由于`ARouter`自身设计原因，其初始化只针对当前进程，这也导致了其路由表的自动注册和拦截器相关机制都是单进程的。

而在目前国内多进程、插件化的多元发展环境下，若想向其它进程的服务直接获取数据，`ARouter`是无能为力的，需要开发者通过`AIDL`等方式来自己实现。

### 6、然后开始洗地

那么导致这些局限性的原因，是因为`ARouter`这类页面路由库自身设计的不足吗，并非完全如此，从技术角度而言，为`ARouter`添加进程间通信的支持是可行的。

大而全的框架往往也是掺杂了各种私货的大杂烩，看似 **功能强大** ，实则 **臃肿不堪** —— 笔者更喜欢类似`Retrofit`的设计，将网络请求的功能 **收敛**，并将 **反序列化**、**返回类型**、**网络请求扩展** 等相关功能通过`Converter`、`Adapter`、`Interceptor`的方式抽象出来，交给开发者选择性依赖后，再自行组装，`Retrofit`自身则绝不多干涉一分一厘。

同样，作为 **页面路由框架** ，`ARouter`目前的设计已满足现有需要。对于进程间通信，`ARouter`可以在`IProvider`的实现中，通过声明`AIDL`进行通信，最终将结果交还给`ARouter`去分发。这也正符合了其开源时所提倡的口号：**简单** 且 **够用**。

现在我们知道，对于业务量级不大，尚以 **页面跳转** 为主要通信手段的应用而言，`ARouter`这类 **页面路由框架** 已足够使用；但是，对于更为复杂的项目而言，组件间 **数据获取** 更加频繁，作为设计者，如何保证灵活性的同时，提供更便捷数据通信的可能呢？

## 二、继续向上抽象

从更抽象化的角度来看，无论是`UI`层级的 **页面跳转**，还是业务层级的 **数据获取**，都可视为 **通信** 的行为。

### 1、通信和通信结果的定义

对此，我们可以对通信协议进行如下的定义：

```java
// 跳转 用户模块 - 登录页面
String loginUrl = "route://com.example.route/user/activity/login"

// 获取 用户模块 - 用户数据
String getUserName = "route://com.example.route/user/service/getUserName"
```

我们可以像`http`请求一样，对页面跳转通信的结果进行如下结构的定义：

```json
// 跳转页面的返回值
{
  "code" : "0000",      // 跳转失败，可以定义一个错误码，比如 "4000"
  "msg"  : "success",
  "data" : null
}
```

而对于数据获取的定义，则可以充分利用`data`字段：

```json
// 获取用户信息
{
  "code" : "0000",
  "msg"  : "success",
  "data" : {
    "userName": "James Moriarty",
    "token": "xxxxxxx"
  }
}
```

这样，无论是哪种通信，我们都将通信的结果抽象为了`Result`，并在代码中进行对应的处理：

```java
class Result {
   @NonNull String code;
   @NonNull String msg;
   @Nullable Object data;
}

// 根据不同种类的通信行为，分别处理result
Result result =  Router.route(url); // url可以是跳转页面，也可以是获取数据
```

### 2、异步通信的支持
