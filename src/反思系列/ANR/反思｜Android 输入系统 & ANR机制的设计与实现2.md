# 反思｜Android 输入系统 & ANR机制的设计与实现

## 四、ANR机制的设计与实现

对 **输入系统** 有了更初步整体的认知之后，接下来本文将针对`ANR`机制进行更深一步的探索。

通常来讲，`ANR`的来源分为`Service、Broadcast、Provider`以及`Input`两种。

这样区分的原因是，首先，前者发生在 **应用进程** 组件中的`ANR`问题通常是相对好解决的，若`ANR`本身容易复现，开发者通常仅需要确定组件的代码中是否在 **主线程中做了耗时处理**；而后者`ANR`发生的原因为 **输入事件** 分发超时，包括按键和屏幕的触摸事件，通过阅读上一章节，读者知道 **输入系统** 中负责处理`ANR`问题的是处于 **系统进程** 中的`InputDispatcher`，其整个流程相比前者而言逻辑更加复杂。

简单理解了之后，读者需要知道，「组件类`ANR`发生原因通常是由于 **主线程中做了耗时处理**」这种说法实际上是笼统的，更准确的讲，其本质的原因是 **组件任务调度超时**，而在设备资源紧凑的情况下，`ANR`的发生更多是综合性的原因。

而`Input`类型的`ANR`相对于`Service、Broadcast、Provider`，其内部的机制又截然不同。

### 1、第一类原理概述

具体不同在哪里呢，对于`Service、Broadcast、Provider`组件类的`ANR`而言，[Gityuan](http://gityuan.com/) 在 [这篇文章](http://gityuan.com/2019/04/06/android-anr/) 中做了一个非常精妙的解释：

> `ANR`是一套监控`Android`应用响应是否及时的机制，可以把发生`ANR`比作是 **引爆炸弹**，那么整个流程包含三部分组成：
> * **埋定时炸弹**：中控系统(`system_server`进程)启动倒计时，在规定时间内如果目标(应用进程)没有干完所有的活，则中控系统会定向炸毁(杀进程)目标。
> * **拆炸弹**：在规定的时间内干完工地的所有活，并及时向中控系统报告完成，请求解除定时炸弹，则幸免于难。
> * **引爆炸弹**：中控系统立即封装现场，抓取快照，搜集目标执行慢的罪证(`traces`)，便于后续的案件侦破(调试分析)，最后是炸毁目标。

将组件的`ANR`机制比喻为 **定时炸弹** 非常贴切，以`Service`为例，对于`Android`系统而言，启动一个服务其本质是进程间的异步通信，那么，如何判断`Service`是否启动成功，如果一直没有成功，那么如何处理？

因此`Android`设计了一个 **置之死地而后生** 的机制，在尝试启动`Service`时，让中控系统`system_server`埋下一个 **定时炸弹** ，当`Service`完成启动，拆掉炸弹；否则在`system_server`的`ActivityManager`线程中引爆炸弹，这就是组件类`ANR`机制的原理：

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/blogs/2020/input_system2.png)

接下来简单了解一下 **输入系统** 流程中`ANR`机制的原理。

### 2、第二类原理概述

`Input`类型的`ANR`在日常开发中更为常见且更复杂，比如用户或者测试反馈，点击屏幕中的UI元素导致「卡死」。

少数情况下开发者能够很快定位到问题，但更常见的情况是，该问题是 **随机** 且 **难以复现** 的，导致该问题的原因也更具有综合性，比如低端设备的系统本身资源已非常紧张，或者多线程相互持有彼此需要的资源导致 **死锁** ，亦或其它复杂的情况，因此处理这类型问题就需要开发者对 **输入系统** 中的`ANR`机制有一定的了解。

与组件类`ANR`不同的是，`Input`类型的超时机制并非时间到了一定就会爆炸，而是处理后续上报事件的过程才会去检测是否该爆炸，所以更像是 **扫雷** 的过程。

什么叫做 **扫雷** 呢，对于 **输入系统** 而言，即使某次事件执行时间超过预期的时长，只要用户后续没有再生成输入事件，那么也不需要`ANR`。

而只有当新一轮的输入事件到来，此时正在分发事件的窗口（即`App`应用本身）迟迟无法释放资源给新的事件去分发，这时`InputDispatcher`才会根据超时时间，动态的判断是否需要向对应的窗口提示`ANR`信息。

这也正是用户在第一次点击屏幕，即使事件处理超时，也没有弹出`ANR`窗口，而当用户下意识再次点击屏幕时，屏幕上才提示出了`ANR`信息的原因。

由此可见，组件类`ANR`和`Input ANR`原理上确实有所不同；除此之外，前者是在`ActivityManager`线程中处理的`ANR`信息，后者则是在`InputDispatcher`线程中处理的`ANR`，这里通过一张图简单了解一下后者的整体流程：

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/20200824195209.png)

现在我们对`Input`类型的`ANR`机制有了一个简单的了解，下文将针对其更深入性的细节实现进行探讨。

### 3、事件分发的异步机制

我们再次将目光转回到`InputDispatcher`的实现细节。

先抛出一个新的问题，对处于`system_server`进程`Native`层级的 **事件分发** 而言，其向下与 **应用进程** 的通信的过程应该是同步还是异步的？

对于读者而言，不难得出答案是异步的，因为两者之间双向通信的建立是通过`SocketPair`，并且，因为`system_server`中`InputDispatcher`对事件的分发实际上是一对多的，如果是同步的，那么一旦其中一个应用分发超时，那么`InputDispatcher`线程自然被卡住，其永远都不可能进入到下一轮的事件分发中，**扫雷** 机制更是无从谈起。

因此，与应用进程中事件分发不同的是，后者我们通常可以认为是在主线程中同步的，而对于整个 **输入系统** 而言，因为涉及到 **系统进程** 与多个 **应用进程** 之间异步的通信，因此其内部的实现更为复杂。

因为事件分发涉及到异步回调机制，因此`InputDispatcher`需要对事件进行维护和管理，那么问题就变成了，使用什么样的数据结构去维护这些输入事件比较合适。

### 4、三个队列

`InputDispatcher`的源码实现中，整体的事件分发流程共使用到3个事件队列：

* mInBoundQueue：用于记录`InputReader`发送过来的输入事件；
* outBoundQueue：用于记录即将分发给目标应用窗口的输入事件；
* waitQueue：用于记录已分发给目标应用，且应用尚未处理完成的输入事件。

下文，笔者通过2轮事件分发的示例，对三个队列的作用进行简单的梳理。

#### 4.1 第一轮事件分发

首先`InputReader`线程通过`EventHub`监听到底层的输入事件上报，并将其放入了`mInBoundQueue`中，同时唤醒了`InputDispatcher`线程。

然后`InputDispatcher`开始了第一轮的事件分发，此时并没有正在处理的事件，因此`InputDispatcher`从`mInBoundQueue`队列头部取出事件，并重置`ANR`的计时，并检查窗口是否就绪，此时窗口准备就绪，将该事件转移到了`outBoundQueue`队列中，因为应用管道对端连接正常，因此事件从`outBoundQueue`取出，然后放入了`waitQueue`队列，因为`Socket`双向通信已经建立，接下来就是 **应用进程** 接收到新的事件，然后对其进行分发。

如果 **应用进程** 事件分发正常，那么会通过`Socket`向`system_server`通知完成，则对应的事件最终会从`waitQueue`队列中移除。

#### 4.2 第二轮事件分发

如果第一轮事件分发尚未接收到回调通知，第二轮事件分发抵达又是如何处理的呢？

第二轮事件到达`InputDispatcher`时，此时`InputDispatcher`发现有事件正在处理，因此不会从`mInBoundQueue`取出新的事件，而是直接检查窗口是否就绪，若未就绪，则进入`ANR`检测状态。

以下几种情况会导致进入`ANR`检测状态：

> 1、目标应用不会空，而目标窗口为空。说明应用程序在启动过程中出现了问题；
> 2、目标`Activity`的状态是`Pause`，即不再是`Focused`的应用；
> 3、目标窗口还在处理上一个事件。

读者需要理解，并非所有「目标窗口还在处理上一个事件」都会抛出`ANR`，而是需要通过检测时间，如果未超时，那么直接中止本轮事件分发，反之，如果事件分发超时，那么才会确定`ANR`的发生。

这也正是将`Input`类型的`ANR`描述为 **扫雷** 的原因：这里的扫雷是指当前输入系统中正在处理着某个耗时事件的前提下，后续的每一次`input`事件都会检测前一个正在处理的事件是否超时（进入扫雷状态），检测当前的时间距离上次输入事件分发时间点是否超时。如果前一个输入事件，则会重置`ANR`的`timeout`，从而不会爆炸。

至此，**输入系统** 检测到了`ANR`的发生，并向上层抛出了本次`ANR`的相关信息。

## 小结

本文旨在对`Android` **输入系统** 进行一个系统性的概述，读者不应将本文作为唯一的学习资料，而应该通过本文对该知识体系进行初步的了解，并根据自身要求进行单个方向细节性的突破。而已经掌握了骨骼架构的读者而言，更细节性的知识点也不过是待丰富的血肉而已。

本文从立题至发布，整个流程耗时近1个半月，在这个过程中，笔者参考了较本文内容数十倍的资料，受益颇深，也深感以 **举重若轻** 为写文目标之艰难——内容铺展容易，但通过 **简洁** 且 **连贯** 的语言来对一个庞大复杂的知识体系进行收拢，需要极强的 **克制力** ，在这种严苛的要求下，每一句的描述都需要极高的 **精确性** ，这对笔者而言是一个挑战，但真正完成之后，对整个知识体系的理解程度同样也是极高的。

而这也正是 [反思](https://github.com/qingmei2/android-programming-profile/blob/master/src/%E5%8F%8D%E6%80%9D%E7%B3%BB%E5%88%97/%E5%8F%8D%E6%80%9D%7C%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95.md) 系列的初衷，希望你能喜欢。

## 参考 & 扩展阅读

正如上文所言，**输入系统** 和 **ANR** 本身都是一个非常大的命题，除了宽广的知识体系，还需要亲身去实践和总结，下文列出若干相关参考资料，读者可根据自身需求选择性进行扩展阅读：

[1、彻底理解安卓应用无响应机制 @Gityuan](http://gityuan.com/2019/04/06/android-anr/)
[2、Input系统—ANR原理分析 @Gityuan](http://gityuan.com/2017/01/01/input-anr/)
[3、理解Android ANR的触发原理 @Gityuan](http://gityuan.com/2016/07/02/android-anr/)

深入学习`ANR`机制资料，`Gityuan`的`ANR`博客系列绝对是先驱级别的，尤其是第1篇文章中，其对于 **定时炸弹** 和 **扫雷** 的形容，贴切且易理解，这种 **举重若轻** 的写作风格体现了作者本身对整个知识体系的深度掌握；而后两篇文章则针对两种类型的`ANR`分别进行了源码级别的分析，非常下饭。

[4、图解Android-Android的 Event Input System @漫天尘沙](https://www.cnblogs.com/samchen2009/p/3368158.html)

笔者曾经想写一个 **图解Android** 系列，后来因为种种原因放弃了，没想到若干年前已经有先驱进行过了这样的尝试，并且，内容质量极高。笔者相信，能够花费非常大精力总结的文章一定不会被埋没，而这篇文章，注定会成为经典中的经典。

[5、Android Input系列 @Stan_Z](https://www.jianshu.com/p/5a879b7ad3b2)

一个笔者最近关注非常优秀的作者，文章非常具有深度，其`Input`系列针对整个输入系统进行了更细致源码级别的分析，非常值得收藏。

[6、Android 信号处理面面观 之 信号定义、行为和来源 @rambo2188](https://blog.csdn.net/rambo2188/article/details/6998349)

如果读者对「`Android`系统信号处理的行为」感兴趣，那么这篇文章绝对不能错过。

7、Android开发高手课 @张绍文

实战中的经典之作，该课程每一小结都极具深度，价值不可估量。因或涉及到利益相关，而且推荐了也从张老师那里拿不到钱，因此本文不加链接并放在最下面（笑）。


---

## 关于我

Hello，我是 [却把清梅嗅](https://github.com/qingmei2) ，如果您觉得文章对您有价值，欢迎 ❤️，也欢迎关注我的 [博客](https://juejin.im/user/588555ff1b69e600591e8462/posts) 或者 [GitHub](https://github.com/qingmei2)。

如果您觉得文章还差了那么点东西，也请通过 **关注** 督促我写出更好的文章——万一哪天我进步了呢？

* [我的Android学习体系](https://github.com/qingmei2/blogs)
* [关于文章纠错](https://github.com/qingmei2/blogs/blob/master/error_collection.md)
* [关于知识付费](https://github.com/qingmei2/blogs/blob/master/appreciation.md)
* [关于《反思》系列](https://github.com/qingmei2/blogs/blob/master/src/%E5%8F%8D%E6%80%9D%E7%B3%BB%E5%88%97/%E5%8F%8D%E6%80%9D%7C%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95.md)
