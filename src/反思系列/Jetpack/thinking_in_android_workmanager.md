# WorkManager 设计与实现

## 困境

作为一名 `Android` 开发者，即使你没有用过，也一定对 `Jetpack WorkManager` 耳熟能详。

自2018年发布以来，作为 `Google` 官方推出的架构组件，它并未像 `LiveData`、`ViewModel` 一样得到广泛应用。究其原因，一起来看 **官方** 当初对 `WorkManager` 的描述：

> **`WorkManager`** 用于执行可 **延迟**、**异步** 的后台任务。它提供了一个 **可靠**、**可调度** 的后台任务执行环境，可以处理 **即使在应用退出或设备重启后仍需要运行** 的任务。

快速提炼这段话的重点，你得到了什么? 

> `WorkManager`，可以处理后台任务，这些任务哪怕手机重启也一定会执行?

坦白地说，看完简介，我的内心毫无波澜，"关机重启仍会执行" 的确很不错，but who cares ? 我根本用不上。

——它给人的第一印象并不惊艳，甚至可以说 **平平无奇** ，无论是相亲市场，还是技术领域，这都非常致命。

时至今日，社区内除了若干 **使用简介** 和 **源码分析** 的博客单篇，我们仍无法找到其 **实战进阶** 或 **最佳实践** 的相关系列。

## 余晖

那么，**它究竟被用来解决什么问题？**

实际上，`WorkManager` 是 **后台任务处理** 领域内的沧海遗珠。我认为它和 `Paging` 一样，是传统 `Android` 领域内学院派编程风格的代表作——悲观一点，甚至可能是薄暮下学院派的最后一抹余晖。

它和 `Paging` 面临着同样难以推广的困境，导致默默无闻：简单的项目用不到，复杂的项目已经积累了其它方案，迁移成本过高。

精兵如炬，困龙难飞。

今天我通过介绍 `WorkManager` 的设计思想，针对 **后台任务管理** 机制进行一个系统性的介绍；实际开发中，`WorkManager` 到底能解决哪些问题，以及最佳实践。
