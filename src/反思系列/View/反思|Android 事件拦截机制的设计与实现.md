# 反思｜Android 事件拦截机制的设计与实现

> **反思** 系列是笔者一个新的尝试，其起源与目录请参考 [这里](https://github.com/qingmei2/android-programming-profile/blob/master/src/%E5%8F%8D%E6%80%9D%E7%B3%BB%E5%88%97/%E5%8F%8D%E6%80%9D%7C%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95.md) 。
## 概述

完整的掌握 `Android` 事件分发体系并非易事，其整个流程涉及到了 **系统启动流程**（`SystemServer`）、**输入管理**(`InputManager`)、**系统服务和UI的通信**（`ViewRootImpl` + `Window` + `WindowManagerService`）、`View`层级的 **事件分发机制** 等等一系列的环节。

**事件拦截机制** 是基于`View`层级 **事件分发机制** 的一个进阶性的知识点，本文将对其进行更细致化的讲解。

**事件拦截机制** 本身就相对比较独立，因此本文不需要读者有 **事件分发机制** 相关的预备知识，对后者感兴趣的读者可以参考以下资料：

> [反思 | Android 事件分发机制的设计与实现](https://juejin.im/post/5d66565cf265da03e71b0672)

本文整体结构如下图：

> TODO1

## 从事件序列说起

### 1、什么是事件序列

想要说清 **事件分发机制** 和 **事件拦截机制**，**事件序列** 是首先要理解的概念。

什么是事件序列？`Google`官方文档中对其描述为 `The duration of the touch`，顾名思义，我们可以将其理解为 **用户一次完整的触摸操作流程**—— 举例来说，用户单击按钮、用户滑动屏幕、用户长按屏幕中某个UI元素等等，都属于该范畴。

### 2、缘由

为什么 **事件序列** 是一个非常重要的概念？

[上一篇文章](https://juejin.im/post/5d66565cf265da03e71b0672) 中，读者已经了解事件分发的本质原理就是递归，对此简单的实现方式是：每接收一个新的事件，都需要进行一次递归才能找到对应消费事件的`View`，并依次向上返回事件分发的结果。

以每个触摸事件作为最基本的单元，都对`View`树进行一次遍历递归？这对性能的影响显而易见，因此这种设计是有改进空间的。

如何针对这个问题进行改进？将 **事件序列** 作为最基本的单元进行处理则更为合适。

首先，设计者根据用户的行为对`MotionEvent`中添加了一个`Action`的属性以描述该事件的行为：

* `ACTION_DOWN`：手指触摸到屏幕的行为
* `ACTION_MOVE`：手指在屏幕上移动的行为
* `ACTION_UP`：手指离开屏幕的行为
* ...其它Action，比如`ACTION_CANCEL`...

我们知道，针对用户的一次触摸操作，必然对应了一个 **事件序列**，从用户手指接触屏幕，到移动手指，再到抬起手指 ——单个事件序列必然包含`ACTION_DOWN`、`ACTION_MOVE` ... `ACTION_MOVE`、`ACTION_UP` 等多个事件，这其中`ACTION_MOVE`的数量不确定，`ACTION_DOWN`和`ACTION_UP`的数量则为1。

熟悉了 **事件序列** 的概念，设计者就可以着手对现有代码进行设计和改进，其思路如下：当接收到一个`ACTION_DOWN`时，意味着一次完整事件序列的开始，通过递归遍历找到真正对事件进行消费的`Child`，并将其进行保存，这之后接收到`ACTION_MOVE`和`ACTION_UP`行为时，则跳过遍历递归的过程，将事件直接分发对应的消费者：

> TODO2 一条链式，树形结构

由此可见，**事件序列** 在 **事件分发** 的知识体系中的确是非常重要的核心概念（甚至没有之一），其最重要的意义是 **足够节省性能**：用户一次正常的触摸行为，其 **事件序列** 包含了若干个触摸事件，这些事件并非每次都通过递归算法去找到事件的消费者，因为这会消耗非常多的内存——**当事件序列越复杂、或者`View`树的层级嵌套越深，这种优势愈发明显。**

那么，源码的设计者是如何保证通过一次递归算法找到`View`树中对应事件消费者的子`View`，其数据结构又是如何的呢？

认真思考，读者不难得出答案：**链表**。

## 构建链表

### 为什么是链表

为什么采用链表，有没有更加简单粗暴的实现方案？

当然，**最符合直觉** 的实现方式似乎是：在通过递归完成第一次事件分发之后，将事件的消费者作为成员保存在当前父`View`中：

> TODO3

不可否认，这样的设计完全可以实现我们需要的效果，但读者仔细思考得知，这种设计有非常大的局限性，其最大问题就是破坏了树形结构的 **内部自治性**。

最顶层`View`直接持有最下层某个`View`的引用合理吗，答案是否定的。首先，这导致`View`层级依赖之间的混乱；其次，顶层`View`本身持有了最下层某个`View`的引用，则这之间若干个层级的`View`的`target`属性都毫无意义。

更能将
