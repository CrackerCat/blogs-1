# 反思｜Android 事件拦截机制的设计与实现

> **反思** 系列是笔者一个新的尝试，其起源与目录请参考 [这里](https://github.com/qingmei2/android-programming-profile/blob/master/src/%E5%8F%8D%E6%80%9D%E7%B3%BB%E5%88%97/%E5%8F%8D%E6%80%9D%7C%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95.md) 。
## 概述

完整的掌握 `Android` 事件分发体系并非易事，其整个流程涉及到了 **系统启动流程**（`SystemServer`）、**输入管理**(`InputManager`)、**系统服务和UI的通信**（`ViewRootImpl` + `Window` + `WindowManagerService`）、`View`层级的 **事件分发机制** 等等一系列的环节。

**事件拦截机制** 是基于`View`层级 **事件分发机制** 的一个进阶性的知识点，本文将对其进行更细致化的讲解。

**事件拦截机制** 本身就相对比较独立，因此本文不需要读者有 **事件分发机制** 相关的预备知识，对后者感兴趣的读者可以参考以下资料：

> [反思 | Android 事件分发机制的设计与实现](https://juejin.im/post/5d66565cf265da03e71b0672)

本文整体结构如下图：

> TODO1

## 从事件序列说起

### 1、什么是事件序列

想要说清 **事件分发机制** 和 **事件拦截机制**，**事件序列** 是首先要理解的概念。

什么是事件序列？`Google`官方文档中对其描述为 `The duration of the touch`，顾名思义，我们可以将其理解为 **用户一次完整的触摸操作流程**—— 举例来说，用户单击按钮、用户滑动屏幕、用户长按屏幕中某个UI元素等等，都属于该范畴。

### 2、缘由

为什么 **事件序列** 是一个非常重要的概念？

[上一篇文章](https://juejin.im/post/5d66565cf265da03e71b0672) 中，读者已经了解事件分发的本质原理就是递归，对此简单的实现方式是：每接收一个新的事件，都需要进行一次递归才能找到对应消费事件的`View`，并依次向上返回事件分发的结果。

以每个触摸事件作为最基本的单元，都对`View`树进行一次遍历递归？这对性能的影响显而易见，因此这种设计是有改进空间的。

如何针对这个问题进行改进？将 **事件序列** 作为最基本的单元进行处理则更为合适。

首先，设计者根据用户的行为对`MotionEvent`中添加了一个`Action`的属性以描述该事件的行为：

* `ACTION_DOWN`：手指触摸到屏幕的行为
* `ACTION_MOVE`：手指在屏幕上移动的行为
* `ACTION_UP`：手指离开屏幕的行为
* ...其它Action，比如`ACTION_CANCEL`...

我们知道，针对用户的一次触摸操作，必然对应了一个 **事件序列**，从用户手指接触屏幕，到移动手指，再到抬起手指 ——单个事件序列必然包含`ACTION_DOWN`、`ACTION_MOVE` ... `ACTION_MOVE`、`ACTION_UP` 等多个事件，这其中`ACTION_MOVE`的数量不确定，`ACTION_DOWN`和`ACTION_UP`的数量则为1。

熟悉了 **事件序列** 的概念，设计者就可以着手对现有代码进行设计和改进，其思路如下：当接收到一个`ACTION_DOWN`时，意味着一次完整事件序列的开始，通过递归遍历找到真正对事件进行消费的`Child`，并将其进行保存，这之后接收到`ACTION_MOVE`和`ACTION_UP`行为时，则跳过遍历递归的过程，将事件直接分发对应的消费者：

> TODO2 一条链式，树形结构

由此可见，**事件序列** 在 **事件分发** 的知识体系中的确是非常重要的核心概念（甚至没有之一），其最重要的意义是 **足够节省性能**：用户一次正常的触摸行为，其 **事件序列** 包含了若干个触摸事件，这些事件并非每次都通过递归算法去找到事件的消费者，因为这会消耗非常多的内存——**当事件序列越复杂、或者`View`树的层级嵌套越深，这种优势愈发明显。**

那么，源码的设计者是如何保证通过一次递归算法找到`View`树中对应事件消费者的子`View`，其数据结构又是如何的呢？

认真思考，读者不难得出答案：**链表**。

### 为什么是链表

为什么采用链表，有没有更加简单粗暴的实现方案？

当然，**最符合直觉** 的实现方式似乎是：在通过递归完成第一次事件分发之后，将事件的消费者作为成员保存在当前父`View`中：

> TODO3

不可否认，这样的设计完全可以实现我们需要的效果，但读者仔细思考得知，这种设计最大的问题就是破坏了树形结构的 **内部自治性**。

最顶层`View`直接持有最下层某个`View`的引用合理吗？答案是否定的。首先，这导致`View`层级依赖之间的混乱；其次，顶层`View`本身持有了最下层某个`View`的引用，则这之间若干个层级的`View`的`target`属性都毫无意义。

更能将树结构应用淋漓尽致的方式是构建一个链表：

> TODO4

每个`View`节点都持有事件的下一级消费者，当同一事件序列后续的触摸事件抵达时，不再需要进行消耗性能的`DFS`算法，而是直接交给下一级的子`View`，子`View`则直接交给下下一级的子`View`，直到事件到达真正的消费者：

> TODO5

和链表的定义类似，设计者设计了`TouchTarget`类，同时为每一个`ViewGroup`都声明这样一个成员，作为链表的一个结点，以描述当前事件序列的传递方向：

```Java
public abstract class ViewGroup extends View {

  // 链表的下一级结点
  private TouchTarget mFirstTouchTarget;

  private static final class TouchTarget {
      // 描述接下来的触摸事件由哪一个子View接收并分发
      public View child;
  }
}
```

那么这个链表是怎么构建的呢？正如上文所说，当接收到一个`ACTION_DOWN`时，意味着一次完整事件序列的开始，通过递归遍历找到真正对事件进行消费的`Child`

读者需认真揣摩 **事件序列** 的相关概念，因为这个知识点贯穿了整个 **事件分发机制** 流程，可以说是非常核心的知识点；同时，掌握它也是下文快速掌握 **事件拦截机制** 的关键。

## 事件拦截机制

大多数`Android`开发者对 **事件拦截机制** 都不会陌生，读者应该都有了解，`ViewGroup`层级额外设计了`onInterceptTouchEvent()`函数并向外暴露给开发者，以达到让`ViewGroup`不再将触摸事件交给`View`处理，而是自身决定是否消费事件，并将结果反馈给上层级的`ViewGroup`。

为什么设计出这样一种拦截机制？其实这是有必要的，以常规的`ScrollView`对应的滑动页面为例，当用户抛出了一个列表的滑动操作，这时，对应的触摸事件序列是否还有必要交给`ScrollView`的子`View`进行处理？

答案是否定的，当`ScrollView`接收到滑动操作时，理所当然，本次滑动操作相关事件都不再需要交给子`View`，而是直接交给`ScrollView`去处理滑动操作。

读者同样需要明白，**并非所有事件序列都会被拦截**——当用户点击`ScrollView`中的某个按钮时，设计者又期望这次的点击操对应的系列事件能够被`ScrollView`分发给子`Button`去处理，这样开发者最终能够在按钮本身的`OnClickListener`中观察到这次点击事件，并进行对应的业务操作。

因此，对于不同类型的`ViewGroup`，开发者需要在不同的场景下，做出是否拦截事件的决定，这种 **父控件根据本身职责去拦截指定场景的事件序列** 的行为，我们称之为 **事件拦截机制**。

### 1、拦截函数：onInterceptTouchEvent

那么开发者如何做，才能保证  **不同场景的事件被合理的向下分发或直接拦截** 呢？设计者据此提供了 `onInterceptTouchEvent()` 拦截函数：

```Java
public abstract class ViewGroup extends View {

  public boolean onInterceptTouchEvent(MotionEvent ev) {
      // ...
      return false;
  }
}
```

其定义是，当触摸事件到来时，事件首先作为参数传入`onInterceptTouchEvent`函数中，开发者通过自定义`onInterceptTouchEvent`决定是否
