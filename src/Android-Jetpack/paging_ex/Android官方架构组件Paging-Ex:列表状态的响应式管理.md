# Android官方架构组件Paging-Ex:列表状态的响应式管理

## 概述

`Paging`是`Google`在2018年I/O大会上推出的适用于`Android`原生开发的分页库，随着越来越多的开发者着手使用`Paging`，越来越多的问题暴露出来，最直接的一个问题是：

> 如何管理列表额外的状态？

这样的需求随处可见，比如 `侧滑删除`、`为评论点赞` 等等：

本文将阐述：如何管理`Paging`分页列表的 **状态**，为何这样设计，以及设计的过程。

## 状态问题

和市面上其它热门的分页库相比，`Paging`最大的亮点在于其 **将列表分页加载的逻辑作为回调函数封装入 `DataSource` 中**，开发者在配置完成后，无需通过代码手动控制分页的加载，列表会 **自动加载** 下一页数据并展示。

这种便利意味着开发者不需要自己持有 **数据源** ，大多数时候这使得开发流程更加便利，但总有偶然，比如这样一个界面：

![图1:为列表点赞]()

这种需求屡见不鲜，其本质是，列表本身展示服务端返回的列表数据之外，还需要 **本地控制额外的状态**。

什么叫 **额外的状态** ? 我们先用简单的一张图展示没有额外状态的情形，这时，列表的所有UI元素都从服务端获取：

![图2:没有额外的状态]()

现在我们将上文`Gif`中的点赞效果也通过一张图表示：

![图3:额外的状态]()

读者可能还没有认识到两种业务场景之间巨大的差异性，对于列表的初始化来讲，所有UI元素都被服务端返回的数据渲染，每条评论是否已经被点赞，服务端都通过`Comment`进行了描述。

接下来需要注意的时间点到了，在某一刻，用户发现某个评论非常有趣，因此他选择对该评论进行了点赞的操作。

在业务代码中，我们需要向服务端`POST`一个点赞的请求，服务端返回了一个200的成功码，但问题来了，接下来我们 **如何让列表中的那条评论状态发生变化**（即点赞的icon由灰色变成绿色高亮，已告知用户点赞成功）？

这就引发了文章最开始的那个问题，**当列表的状态发生了变更，如何管理并更新列表？**

### 1.最简单方案，再次刷新请求接口

最简单的方案是再次请求API，每当列表状态发生了变更，重新拉取评论列表，服务端返回的最新数据中，该评论数据自然已经被点赞了（即列表正确进行了更新）。

但读者稍微一思考，就会很轻易明白该方案并不可行，原因有二：

* **成本太高**：某些操作对于用户来说，应该是非常 **轻量级** 的（比如点赞），他们甚至希望这些操作能够 **立即被响应** ，而请求API并刷新列表这一个过程太重了，即使不考虑服务器的负担，对于用户来说，数秒的等待也是非常糟糕的体验。  
* **不符合逻辑**：我们更需要注意的是，`Paging`是一个分页列表，而 **刷新请求行为** 对于分页列表来说，是一个不符合产品预期的行为（比如，我的点赞操作是针对第5页的某个评论执行的，产品的设计不可能允许每次点赞都重置为列表的第一页数据，这意味着极度糟糕的用户体验）。
